#+TITLE: Leetcode Easy Solutions
#+AUTHOR: lloydlobo
#+STARTUP: showeverything
#+OPTIONS: num:nil ^:{}
# #+PROPERTY: header-args :tangle yes :results none
-----

* Table Of Contents :toc:
- [[#][───────────────────────────────────────────────────────────]]
- [[#0001-two-sum][0001 TWO SUM]]
  - [[#source][Source]]
  - [[#explanation][Explanation]]
  - [[#alternatives][Alternatives]]
- [[#0009-palindrome-number][0009 PALINDROME NUMBER]]
  - [[#source-1][Source]]
- [[#0704-binary-search][0704 BINARY SEARCH]]
  - [[#source-2][Source]]
  - [[#explanation-1][Explanation]]
  - [[#constraints][Constraints:]]

* ───────────────────────────────────────────────────────────
* 0001 TWO SUM
** Source
#+NAME: two-sum
#+begin_src go :tangle ./0001_two-sum/main.go :noweb yes :comments link
package main

import "fmt"

func twoSum(nums []int, target int) []int {
	len := len(nums)
	for i := 0; i < len-1; i += 1 {
		for j := i + 1; j < len; j += 1 {
			sum := nums[i] + nums[j]
			if sum == target {
				return []int{i, j}
			}
		}
	}

	return []int{}
}

func main() {
	fmt.Println("001_two-sum/main.go: main()")
	nums := []int{2, 7, 10, 15}
	target := 9
	output := twoSum(nums, target)
	fmt.Println("\nOutput:", output)
}
#+end_src

** Explanation
URL: https://www.code-recipe.com/post/two-sum
 - For a given input array this algorithm does the following steps:
 - Create a hashmap which accepts integer datatype as key and value.
 - Iterate through each element in the given array starting from the first element.
 - In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
 - If present, return {required number index, current number index} as  result.
 - Otherwise add the current iteration number as key and its index as value to the hashmap. Repeat this  until you find the result.

** Alternatives
#+NAME: two-sum alternative
#+begin_src go
package main

import (
	"fmt"
	"time"
)

/*
 ,* twoSum()
 ,*
 ,* Runtime: 45 ms, faster than 23.21% of go online submissions for two sum.
 ,* Memory Usage: 3.7 MB, less than 75.17% of Go online submissions for Two Sum.
 ,*/
func twoSum(nums []int, target int) []int {
	len := len(nums)
	for i := 0; i < len-1; i += 1 {
		for j := i + 1; j < len; j += 1 {
			if nums[i]+nums[j] == target {
				// fmt.Println("",nums[i], nums[j])
				return []int{i, j}
			}
		}
	}

	return []int{}
}

/*
 ,* Runtime: 17 ms, faster than 41.20% of Go online submissions for Two Sum.
 ,* Memory Usage: 4.4 MB, less than 38.75% of Go online submissions for Two Sum.
 ,*/
func twoSumLookupMap(nums []int, target int) []int {
	count := make(map[int]int)
	for i, num := range nums {
		j, ok := count[num]
		if ok {
			return []int{j, i}
		}
		count[target-num] = i
	}
	return []int{}
}

func main() {
	nums := []int{2, 7, 11, 15}
	target := 9
	output := twoSum(nums, target)
	fmt.Println("Output:", output)
}

/* https://www.code-recipe.com/post/two-sum
 ,* For a given input array this algorithm does the following steps:
 ,* Create a hashmap which accepts integer datatype as key and value.
 ,* Iterate through each element in the given array starting from the first element.
 ,* In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
 ,* If present, return {required number index, current number index} as  result.
 ,* Otherwise add the current iteration number as key and its index as value to the hashmap. Repeat this  until you find the result.
 ,*/
func twoSumIsSeenMapnums(nums []int, target int) []int {
	// Create a hashmap which accepts integer datatype as key and value.
	mapIndex := make(map[int]int)
	// Iterate through each element in the given array starting from the first element.
	for idxCurr, numCurr := range nums {
		// In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
		if idxRequired, isPresent := mapIndex[target-numCurr]; isPresent {
			return []int{idxRequired, idxCurr}
		}
		// Otherwise add the current iteration number as key and its index as value to the hashmap.
		// Repeat this  until you find the result.
		mapIndex[numCurr] = idxCurr
	}

	return []int{}
}

// With slices leave out the element count => Array [4]String or [...]String (compiler will count it)
func sleep(n int) {
	for { // Run infinite loop
		if n <= 0 {
			break // if n is reduced to or below zero break loop
		} else {
			loadingChar := "."
			fmt.Printf("%v", loadingChar)
			time.Sleep(300 * time.Millisecond) // wait 300 milliseconds
			n -= 1                             // reverse countdown
		}
	}
}

// func slice() { var intSlice []int var strSlice []string fmt.Println(reflect.ValueOf(intSlice).Kind()) fmt.Println(reflect.ValueOf(strSlice).Kind()) }
func getIndex(prev int, curr int, i int, j int, target int) []int {
	sum := curr + prev
	fmt.Println("func getIndex Output: num at index", i, "and", j, "is", sum)
	return []int{i, j}
}

func twoSumSlice(nums []int, target int) []int {
	var result []int
	var sliceResult [][]int
	lenNums := len(nums)

	for i := 0; i <= lenNums-1; i += 1 {
		for j := 0; j <= lenNums-1; j += 1 {
			prev := nums[i]
			curr := nums[j]
			/* sleep(3)
			fmt.Println("", prev, curr) */
			if curr+prev == target {
				result = getIndex(prev, curr, i, j, target)
				resultSlice := [][]int{result}
				// arrResult = append(arrResult, result...)
				sliceResult = append(sliceResult, resultSlice...)
				fmt.Println("result:", result)
			}

		}
	}

	return sliceResult[0]
}

// Time: O(n*n) = O(n^2)
// Space: O(1)

func twoSumForLoop(nums []int, target int) []int {
	// O(n)
	for i := 0; i < len(nums)-1; i++ {
		// O(n)
		for j := i + 1; j < len(nums); j++ {
			// Time: O(1)
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
	return []int{}
}

/* for i := 0; i < len(arrResult); i += 1 {
	arr := arrResult[i]

	for j := 0; j < len(arr); j += 1 {
		slice := arrResult[i][j]
		fmt.Print(" slice: ", slice, " i: ", i, " j: ", j, arrResult[i], arrResult[j])
	}
}
fmt.Println("\narrResult:", arrResult) */

func twoSumHashMap(nums []int, target int) []int {
	seenNums := make(map[int]int)
	for index, thisNum := range nums {
		if seenIndex, ok := seenNums[target-thisNum]; ok {
			return []int{seenIndex, index}
		}
		seenNums[thisNum] = index
	}
	return []int{0, 0} // Should not happen
}
#+end_src
* 0009 PALINDROME NUMBER
** Source
#+NAME: palindrome-number
#+begin_src go :tangle ./0009_palindrome-number/main.go :comments link :noweb yes
package main

// works
import (
	"fmt"
	"strconv"
	// "strings"
)

/*
	 reverseStr() Function.
		  https://www.geeksforgeeks.org/how-to-reverse-a-string-in-golang/
			type string string
			string is the set of all strings of 8\-bit bytes, conventionally but not necessarily representing UTF\-8\-encoded text\.
			A string may be empty, but not nil\. Values of string type are immutable\. [`string` on pkg.go.dev](https://pkg.go.dev/builtin?utm_source=gopls#string)
,*/
func reverseStr(str string) (result string) {
	// Append the result at each for loop turn at the end of string.
	for _, v := range str {
		result = string(v) + result
	}
	return
}

func isPalindrome(x int) bool {
	strX := strconv.FormatInt(int64(x), 10)
	strRevX := reverseStr(strX)
	return strX == strRevX
} // fmt.Println("strX:", strX, "strings", strRevX)

func printResult(int int) {
	result := isPalindrome(int)
	fmt.Println("Output:", int, "isPalindrome", result)
}

// ────────────────────────────────────────────────────────────────────────────
func main() {
	sliceIntNums := []int{121, 212, 123, 101}
	for _, intNum := range sliceIntNums {
		printResult(intNum)
	}
}

#+end_src

#+RESULTS:
: Output: true





* 0704 BINARY SEARCH
** Source
#+NAME: binary-search
#+begin_src go :tangle ./0704_binary-search/main.go :noweb yes :comments link

// Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.
// If target exists, then return its index. Otherwise, return -1.
//
// You must write an algorithm with O(log n) runtime complexity.
//
// https://leetcode.com/problems/binary-search/
//
/*
   EXAMPLES:
     Example 1:
        Input: nums = [-1,0,3,5,9,12], target = 9
        Output: 4
        Explanation: 9 exists in nums and its index is 4

     Example 2:
        Input: nums = [-1,0,3,5,9,12], target = 2
        Output: -1
        Explanation: 2 does not exist in nums so return -1

     Example 3:
        Input: arr[] = {10, 20, 30, 50, 60, 80, 110, 130, 140, 170}, x = 110
        Output: 6
        Explanation: Element x is present at index 6.

     Example 4:
        Input: arr[] = {10, 20, 30, 40, 60, 110, 120, 130, 170}, x = 175
        Output: -1
        Explanation: Element x is not present in arr[].
*/
//
// Constraints:
//
//   - 1 <= nums.length <= 104
//   - -104 < nums[i], target < 104
//   - All the integers in nums are unique.
//   - nums is sorted in ascending order.
package main

import (
	"fmt"
	"log"
	"sort"
	"stdout"
	// "time"
)

// Runtime: 68 ms, faster than 27.39% of Go online submissions for Binary SearchForLoop.
// Memory Usage: 6.7 MB, less than 94.45% of Go online submissions for Binary SearchForLoop.
func SearchForLoop(nums []int, target int) int {
	for i := 0; i < len(nums); i++ {
		if nums[i] == target {
			return i
		}
	}

	return -1
}

func getRandomNumsSlice(count int) ([]int, int, int) {
	nums := []int{10, 20, 30, 50, 60, 80, 110, 130, 140, 170}
	len := len(nums)
	for idx := 0; idx < count; idx++ {
		// nums = append(nums, rand.Int())
		nums = append(nums, nums[len-1]+idx*10)
	}
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] < nums[j]
	})

	// len2 := len(nums)
	// mid := len2 - len1
	// fmt.Printf("nums: %v\n", nums)

	return nums, 60, 5

}

func getNumsTargets() ([]int, int, int) {
	nums := []int{10, 20, 30, 50, 60, 80, 110, 130, 140, 170}
	target := 110
	want := 6

	return nums, target, want
}

// Binary Search Algorithm: The basic steps to perform Binary Search are:
//
// https://www.geeksforgeeks.org/binary-search/
//
//	Begin with the mid element of the whole array as a search key.
//	If the value of the search key is equal to the item then return an index of the search key.
//	Or if the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.
//	Otherwise, narrow it to the upper half.
//	Repeatedly check from the second point until the value is found or the interval is empty.
//
// # Binary Search Algorithm can be implemented in the following two ways
//
// Iterative Method
// Recursive Method
func SearchIterative(nums []int, target int) int {
	n := len(nums) // length of the slice/array
	left := 0      // left: is the first position at 0
	right := n - 1 // right: 0 index means we subtract one from len

	for right-left > 1 {
		mid := (right + left) / 2
		// time.Sleep(time.Second * 1)
		// fmt.Printf("nums: %2v \n ", nums)
		// fmt.Printf("\rleft: %2v: %v | mid: %2v: %v | right: %2v: %v \n", left, nums[left], mid, nums[mid], right, nums[right])

		if target == nums[mid] {
			return mid // If target is in the middle itself
		} else if target > nums[mid] {
			// increment the position to right
			left = mid + 1 // If target is less than mid then it will be in the right subarray/slice
		} else {
			right = mid - 1 // else the target can only be present in the left subarray/slice
		}
	} // for as a while loop

	// If the element is not present in slice/array
	return -1
}

// SearchRecursive
//
// Credits: https://www.geeksforgeeks.org/binary-search/
//
// l, r := 0, len(nums)-1 // left & right
func SearchRecursive(nums []int, target int, l, r int) int {
	if r >= l {
		mid := (r + l) / 2 // Or l + (r - l) / 2.

		if nums[mid] == target {
			return mid // If the target is in the middle itself.
		} else if nums[mid] > target {
			rSub := mid - 1 // move to the left
			return SearchRecursive(nums, target, l, rSub)
		} else {
			lAdd := mid + 1 // move to the right
			return SearchRecursive(nums, target, lAdd, r)
		}
	}

	return -1
}

func main() {
	log.SetFlags(log.Ldate | log.Lshortfile)
	log.Println("| 0704_binary-search/main.go: main()")
	nums := []int{-1, 0, 3, 5, 9, 12}
	target := 9

	output := SearchForLoop(nums, target)
	fmt.Printf("\nSearchForLoop:%2v\n", output)

	nums, target, _ = getNumsTargets()
	outputIterative := SearchIterative(nums, target)
	fmt.Println("\nSearchIterative:", outputIterative)

	// nums, target, _ = getRandomNumsSlice(20)
	// outputIterative = SearchIterative(nums, target)
	// fmt.Println("\nSearchIterative:", outputIterative)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 3
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive := SearchRecursive(nums, target, 0, len(nums))
	fmt.Println("\nSearchRecursive:", outputRecursive)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 1
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive = SearchRecursive(nums, target, 0, len(nums))
	fmt.Printf("\nSearchRecursive: %2v \n\n", outputRecursive)
	// stdout.OutputToFile("file.log")

	stdout.OutputToFile("")

}
#+end_src

** Explanation
URL: https://leetcode.com/problems/binary-search/
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

*** Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

*** Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

** Constraints:
    - 1 <= nums.length <= 104
    - -104 < nums[i], target < 104
    - All the integers in nums are unique.
    - nums is sorted in ascending order.
