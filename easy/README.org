#+TITLE: Leetcode Easy Solutions
#+AUTHOR: lloydlobo
#+STARTUP: fold
#+OPTIONS: num:nil ^:{}
# #+PROPERTY: header-args :main no :comments link :noweb yes
# #+PROPERTY: header-args :tangle yes :results none
-----

* Table Of Contents :toc:
- [[#0001-two-sum][0001. TWO SUM]]
  - [[#source][Source]]
  - [[#explanation][Explanation]]
  - [[#alternatives][Alternatives]]
- [[#0009-palindrome-number][0009. PALINDROME NUMBER]]
  - [[#source-1][Source]]
- [[#0175-combine-two-tables][0175. COMBINE TWO TABLES]]
  - [[#source-2][SOURCE]]
- [[#0344-reverse-string][0344-reverse-string]]
  - [[#go][Go]]
  - [[#explanation-1][Explanation]]
- [[#0412-fizz-buzz][0412. FIZZ BUZZ]]
  - [[#source-3][Source]]
  - [[#explanation-2][Explanation]]
  - [[#examples][Examples]]
  - [[#constraints][Constraints]]
  - [[#complexity][Complexity]]
- [[#0628-maximum-product-of-three-numbers][0628. MAXIMUM PRODUCT OF THREE NUMBERS]]
  - [[#source-4][Source]]
  - [[#explanation-3][Explanation]]
  - [[#constraints-1][Constraints]]
  - [[#examples-1][Examples]]
- [[#0704-binary-search][0704. BINARY SEARCH]]
  - [[#source-5][Source]]
  - [[#explanation-4][Explanation]]
  - [[#constraints-2][Constraints:]]
- [[#1752-check-if-array-is-sorted-and-rotated][1752. Check if Array Is Sorted and Rotated]]
  - [[#source-6][Source]]
  - [[#explanation-5][Explanation]]
  - [[#examples-2][Examples]]
- [[#1913-maximum-product-difference-between-two-pairs][1913. Maximum Product Difference Between Two Pairs]]
  - [[#sort][sort]]
  - [[#clone][clone]]
  - [[#minmax][minmax]]

* 0001. TWO SUM
** Source
#+NAME: two-sum
#+begin_src go :tangle ./0001_two-sum/main.go :noweb yes :comments link
package main

import "fmt"

func twoSum(nums []int, target int) []int {
	len := len(nums)
	for i := 0; i < len-1; i += 1 {
		for j := i + 1; j < len; j += 1 {
			sum := nums[i] + nums[j]
			if sum == target {
				return []int{i, j}
			}
		}
	}

	return []int{}
}

func main() {
	fmt.Println("001_two-sum/main.go: main()")
	nums := []int{2, 7, 10, 15}
	target := 9
	output := twoSum(nums, target)
	fmt.Println("\nOutput:", output)
}
#+end_src

#+RESULTS: two-sum
: 001_two-sum/main.go: main()
:
: Output: [0 1]

** Explanation
URL: https://www.code-recipe.com/post/two-sum
 - For a given input array this algorithm does the following steps:
 - Create a hashmap which accepts integer datatype as key and value.
 - Iterate through each element in the given array starting from the first element.
 - In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
 - If present, return {required number index, current number index} as  result.
 - Otherwise add the current iteration number as key and its index as value to the hashmap. Repeat this  until you find the result.

** Alternatives
#+NAME: two-sum alternative
#+begin_src go
package main

import (
	"fmt"
	"time"
)

/*
 ,* twoSum()
 ,*
 ,* Runtime: 45 ms, faster than 23.21% of go online submissions for two sum.
 ,* Memory Usage: 3.7 MB, less than 75.17% of Go online submissions for Two Sum.
 ,*/
func twoSum(nums []int, target int) []int {
	len := len(nums)
	for i := 0; i < len-1; i += 1 {
		formain() {
	nums := []int{2, 7, 11, 15}
	target := 9
	output := twoSum(nums, target)
	fmt.Println("Output:", output)
}

/* https://www.code-recipe.com/post/two-sum
 ,* For a given input array this algorithm does the following steps:
 ,* Create a hashmap which accepts integer datatype as key and value.
 ,* Iterate through each element in the given array starting from the first element.
 ,* In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
 ,* If present, return {required number index, current number index} as  result.
 ,* Otherwise add the current iteration number as key and its index as value to the hashmap. Repeat this  until you find the result.
 ,*/
func twoSumIsSeenMapnums(nums []int, target int) []int {
	// Create a hashmap which accepts integer datatype as key and value.
	mapIndex := make(map[int]int)
	// Iterate through each element in the given array starting from the first element.
	for idxCurr, numCurr := range nums {
		// In each iteration check if required number (required  number = target sum - current number) is present in the hashmap.
		if idxRequired, isPresent := mapIndex[target-numCurr]; isPresent {
			return []int{idxRequired, idxCurr}
		}
		// Otherwise add the current iteration number as key and its index as value to the hashmap.
		// Repeat this  until you find the result.
		mapIndex[numCurr] = idxCurr
	}

	return []int{}
}

// With slices leave out the element count => Array [4]String or [...]String (compiler will count it)
func sleep(n int) {
	for { // Run infinite loop
		if n <= 0 {
			break // if n is reduced to or below zero break loop
		} else {
			loadingChar := "."
			fmt.Printf("%v", loadingChar)
			time.Sleep(300 * time.Millisecond) // wait 300 milliseconds
			n -= 1                             // reverse countdown
		}
	}
}

// func slice() { var intSlice []int var strSlice []string fmt.Println(reflect.ValueOf(intSlice).Kind()) fmt.Println(reflect.ValueOf(strSlice).Kind()) }
func getIndex(prev int, curr int, i int, j int, target int) []int {
	sum := curr + prev
	fmt.Println("func getIndex Output: num at index", i, "and", j, "is", sum)
	return []int{i, j}
}

func twoSumSlice(nums []int, target int) []int {
	var result []int
	var sliceResult [][]int
	lenNums := len(nums)

	for i := 0; i <= lenNums-1; i += 1 {
		for j := 0; j <= lenNums-1; j += 1 {
			prev := nums[i]
			curr := nums[j]
			/* sleep(3)
			fmt.Println("", prev, curr) */
			if curr+prev == target {
				result = getIndex(prev, curr, i, j, target)
				resultSlice := [][]int{result}
				// arrResult = append(arrResult, result...)
				sliceResult = append(sliceResult, resultSlice...)
				fmt.Println("result:", result)
			}

		}
	}

	return sliceResult[0]
}

// Time: O(n*n) = O(n^2)
// Space: O(1)

func twoSumForLoop(nums []int, target int) []int {
	// O(n)
	for i := 0; i < len(nums)-1; i++ {
		// O(n)
		for j := i + 1; j < len(nums); j++ {
			// Time: O(1)
			if nums[i]+nums[j] == target {
				return []int{i, j}
			}
		}
	}
	return []int{}
}

/* for i := 0; i < len(arrResult); i += 1 {
	arr := arrResult[i]

	for j := 0; j < len(arr); j += 1 {
		slice := arrResult[i][j]
		fmt.Print(" slice: ", slice, " i: ", i, " j: ", j, arrResult[i], arrResult[j])
	}
}
fmt.Println("\narrResult:", arrResult) */

func twoSumHashMap(nums []int, target int) []int {
	seenNums := make(map[int]int)
	for index, thisNum := range nums {
		if seenIndex, ok := seenNums[target-thisNum]; ok {
			return []int{seenIndex, index}
		}
		seenNums[thisNum] = index
	}
	return []int{0, 0} // Should not happen
}
#+end_src
* 0009. PALINDROME NUMBER
** Source
#+NAME: palindrome-number
#+begin_src go :tangle ./0009_palindrome-number/main.go :comments link :noweb yes
package main

// works
import (
	"fmt"
	"strconv"
	// "strings"
)

/*
	 reverseStr() Function.
		  https://www.geeksforgeeks.org/how-to-reverse-a-string-in-golang/
			type string string
			string is the set of all strings of 8\-bit bytes, conventionally but not necessarily representing UTF\-8\-encoded text\.
			A string may be empty, but not nil\. Values of string type are immutable\. [`string` on pkg.go.dev](https://pkg.go.dev/builtin?utm_source=gopls#string)
*/
func reverseStr(str string) (result string) {
	// Append the result at each for loop turn at the end of string.
	for _, v := range str {
		result = string(v) + result
	}
	return
}

func isPalindrome(x int) bool {
	strX := strconv.FormatInt(int64(x), 10)
	strRevX := reverseStr(strX)
	return strX == strRevX
} // fmt.Println("strX:", strX, "strings", strRevX)

func printResult(int int) {
	result := isPalindrome(int)
	fmt.Println("Output:", int, "isPalindrome", result)
}

// ────────────────────────────────────────────────────────────────────────────
func main() {
	sliceIntNums := []int{121, 212, 123, 101}
	for _, intNum := range sliceIntNums {
		printResult(intNum)
	}
}
#+end_src

#+RESULTS:
: Output: true
* 0175. COMBINE TWO TABLES
** SOURCE
*** MYSQL
#+NAME: 0175-combine-two-tables
#+begin_src sql :tangle ./0175-combine-two-tables/my.sql :comments link :noweb yes :main no
--
# 0175. Combine Two Tables
--
-- Write an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.
-- Return the result table in any order.
--
-- https://leetcode.com/problems/combine-two-tables/
--
-- Runtime: 598 ms.
-- Memory:  0B.

SELECT Person.firstName, Person.lastName, Address.city, Address.state
FROM Person LEFT JOIN Address
ON Person.personId = Address.personId

-- ---------------------------------------------------

-- +-----------+----------+---------------+----------+
-- | firstName | lastName | city          | state    |
-- +-----------+----------+---------------+----------+
-- | Allen     | Wang     | Null          | Null     |
-- | Bob       | Alice    | New York City | New York |
-- +-----------+----------+---------------+----------+

-- --------------------------------------------------

-- Example 1:
--
-- Input:
-- Person table:
-- +----------+----------+-----------+
-- | personId | lastName | firstName |
-- +----------+----------+-----------+
-- | 1        | Wang     | Allen     |
-- | 2        | Alice    | Bob       |
-- +----------+----------+-----------+
-- Address table:
-- +-----------+----------+---------------+------------+
-- | addressId | personId | city          | state      |
-- +-----------+----------+---------------+------------+
-- | 1         | 2        | New York City | New York   |
-- | 2         | 3        | Leetcode      | California |
-- +-----------+----------+---------------+------------+
-- Output:
-- +-----------+----------+---------------+----------+
-- | firstName | lastName | city          | state    |
-- +-----------+----------+---------------+----------+
-- | Allen     | Wang     | Null          | Null     |
-- | Bob       | Alice    | New York City | New York |
-- +-----------+----------+---------------+----------+
-- Explanation:
-- There is no address in the address table for the personId = 1 so we return null in their city and state.
-- addressId = 1 contains information about the address of personId = 2.

-- ---------------------------------------------------

-- SQL Schema
--
-- Table: Person
--
-- +-------------+---------+
-- | Column Name | Type    |
-- +-------------+---------+
-- | personId    | int     |
-- | lastName    | varchar |
-- | firstName   | varchar |
-- +-------------+---------+
-- personId is the primary key column for this table.
-- This table contains information about the ID of some persons and their first and last names.
--
--
--
-- Table: Address
--
-- +-------------+---------+
-- | Column Name | Type    |
-- +-------------+---------+
-- | addressId   | int     |
-- | personId    | int     |
-- | city        | varchar |
-- | state       | varchar |
-- +-------------+---------+
-- addressId is the primary key column for this table.
-- Each row of this table contains information about the city and state of one person with ID = PersonId.
--
--
--
-- Write an SQL query to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.
--
-- Return the result table in any order.
--
-- The query result format is in the following example.
--
--
#+end_src
* 0344-reverse-string
** Go
#+name: 0344-reverse-string/go
#+begin_src go :tangle ./0344-reverse-string/go/algo/reverse_string.go :noweb yes :comments link :main no
package algo

// Write a function that reverses a string.
// - The input string is given as an array of characters s.
// - You must do this by modifying the input array in-place with O(1) extra memory.
// Constraints:
// 1 <= s.length <= 105
// s[i] is a printable ascii character.
func ReverseString(s []byte) string{
	return "Hello"
}



#+end_src

#+RESULTS:

** Explanation
Write a function that reverses a string.
- The input string is given as an array of characters s.
- You must do this by modifying the input array in-place with O(1) extra memory.
*** Constraints:
1 <= s.length <= 105
s[i] is a printable ascii character.
*** Example 1:
#+begin_example
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
#+end_example
*** Example 2:
#+begin_example
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
#+end_example


* 0412. FIZZ BUZZ
** Source
*** Go
**** main
#+begin_src go :tangle ./0412_fizz-buzz/main.go :main no :noweb yes :comments link
package main

import (
	"fmt"
	"strconv"
)

// fizzBuzz function swaps any integer divisible by 3, 5, or 15.
//
// # Brute Force
// Given a number n, Run a loop from 1 to n
//
//	If a number is divisible by 15.Print FizzBuzz
//	Else If a number is divisible by 3.Print Fizz
//	Else a number is divisible by 3.Print Buzz
//
// # Constraints:
//   - `1 <= n <= 104`
//
// https://www.tutorialcup.com/interview/algorithm/fizz-buzz.html
// Time complexity = O(n) where n is the number till we have to print the values in the fizz buzz way.
// Space Complexity = O(n).
// https://leetcode.com/problems/fizz-buzz/submissions/
// Runtime: 10 ms.
// Memory Usage: 4.3 MB.
func fizzBuzz(n int) []string {
	var output []string

	for i := 1; i < n+1; i++ {
		output = append(output, fmt.Sprint(i))

		if (i)%15 == 0 {
			output[i-1] = "FizzBuzz"
		} else if (i)%3 == 0 {
			output[i-1] = "Fizz"
		} else if (i)%5 == 0 {
			output[i-1] = "Buzz"
		}
		// FIXME: Add an `else` statement to append `i` to `output` slice
		// when `i` is not divisible by 3,5,15.
	}
	return output
}

// FizzBuzzAppend()
//
// Time complexity = O(n) where n is the number till we have to print the values in the fizz buzz way.
// Space Complexity = O(n).
//
// Runtime: 7 ms.
// Memory Usage: 3.4 MB.
func FizzBuzzAppend(n int) []string {
	var arr = make([]string, 0, n) // The make built\-in function allocates and initializes an object of type slice, map, or chan (only).

	for i := 1; i < n+1; i++ {
		if (i)%15 == 0 {
			arr = append(arr, "FizzBuzz")
		} else if (i)%3 == 0 {
			arr = append(arr, "Fizz")
		} else if (i)%5 == 0 {
			arr = append(arr, "Buzz")
		} else {
			arr = append(arr, strconv.Itoa(i)) // Itoa is equivalent to FormatInt(int64(i), 10).
		}
	}
	return arr
}

// main function to print the output to console.
func main() {
	n := 16
	fmt.Printf("fizzBuzz: %v\n", fizzBuzz(n))
	n = 16
	fmt.Printf("fizzBuzz: %v\n", FizzBuzzAppend(n))
}

//   conversion from int to string yields a string of one rune, not a string of digits (did you mean fmt.Sprint(x)?) stringintconv [11, 27]
#+end_src

** Explanation
Given an integer n, return a string array answer (1-indexed) where:
#+begin_example go
answer[i] == "FizzBuzz" if i is divisible by 3 and 5.
answer[i] == "Fizz" if i is divisible by 3.
answer[i] == "Buzz" if i is divisible by 5.
answer[i] == i (as a string) if none of the above conditions are true.
#+end_example

** Examples
*** Example 1:
Input: n = 3
Output: ["1","2","Fizz"]
*** Example 2:
Input: n = 5
Output: ["1","2","Fizz","4","Buzz"]
*** Example 3:
Input: n = 15
Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
** Constraints
- 1 <= n <= 104
** Complexity
- Time complexity = O(n) where n is the number till we have to print the values in the fizz buzz way.
- Space Complexity = O(n).
* 0628. MAXIMUM PRODUCT OF THREE NUMBERS
** Source
*** Go
#+NAME: maximum-product-of-three-numbers
#+begin_src go :tangle ./0628_maximum-product-of-three-numbers/main.go :noweb yes :comments link :main no

// 628. Maximum Product of Three Numbers.
//
// Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
//
// Example 1:
// Input: nums = [1,2,3]
// Output: 6
//
// Example 2:
// Input: nums = [1,2,3,4]
// Output: 24
//
// Example 3:
// Input: nums = [-1,-2,-3]
// Output: -6
//
// Constraints:
// - 3 <= nums.length <= 104
// - -1000 <= nums[i] <= 1000
package main

import (
	"github.com/lloydlobo/leetcode/singlescan"
	"github.com/lloydlobo/leetcode/sorting"
	"github.com/lloydlobo/leetcode/testcases"
)

func main() {
	arrNums, arrWant := testcases.GetMainArgs()
	n := len(arrNums) - 1

	testcases.ExecForLoop(singlescan.MaximumProductSingleScan, arrNums, arrWant, n)
	testcases.ExecForLoop(sorting.MaximumProductSorting, arrNums, arrWant, n)
}
#+end_src
** Explanation
** Constraints
** Examples
* 0704. BINARY SEARCH
** Source
*** Go
#+NAME: binary-search
#+begin_src go :tangle ./0704_binary-search/main.go :noweb yes :comments link

// Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.
// If target exists, then return its index. Otherwise, return -1.
//
// You must write an algorithm with O(log n) runtime complexity.
//
// https://leetcode.com/problems/binary-search/
//
// Constraints:
//
//   - 1 <= nums.length <= 104
//   - -104 < nums[i], target < 104
//   - All the integers in nums are unique.
//   - nums is sorted in ascending order.
package main

import (
	"fmt"
	"log"
	"sort"
	"stdout"
)

// Runtime: 31 ms, faster than 95.31% of Go online submissions for Binary Search.
// Memory Usage: 6.7 MB, less than 94.48% of Go online submissions for Binary Search.
//
// Runtime: 32 ms, faster than 93.68% of Go online submissions for Binary Search.
// Memory Usage: 6.5 MB, less than 99.96% of Go online submissions for Binary Search.
func searchDivideAndConquer(nums []int, target int) int {
	low, high := 0, len(nums)-1 // left: is the first position at 0// right: 0 index means we subtract one from len
	for low <= high {
		mid := (low + high) / 2
		if nums[mid] == target {
			return mid // If target is in the middle itself
		} else if nums[mid] > target {
			high-- // high = mid - 1 //  else the target can only be present in the left subarray/slice
		} else {
			low++ // low = low + 1 // If target is less than mid then it will be in the right subarray/slice
		}
	}
	return -1
}

// Runtime: 40 ms, faster than 72.72% of Go online submissions for Binary Search.
// Memory Usage: 7.1 MB, less than 53.18% of Go online submissions for Binary Search.
//
// Runtime: 33 ms, faster than 91.94% of Go online submissions for Binary Search.
// Memory Usage: 7 MB, less than 61.39% of Go online submissions for Binary Search.
func searchBruteForce(nums []int, target int) int {
	for i := 0; i < len(nums); i++ {
		if nums[i] == target {
			return i
		}
	}
	return -1
}

func main() {
	log.SetFlags(log.Ldate | log.Lshortfile)
	log.Println("| 0704_binary-search/main.go: main()")
	nums := []int{-1, 0, 3, 5, 9, 12}
	target := 9

	searchRunMain()

	output := SearchForLoop(nums, target)
	fmt.Printf("\nSearchForLoop:%2v\n", output)

	nums, target, _ = getNumsTargets()
	outputIterative := SearchIterative(nums, target)
	fmt.Println("\nSearchIterative:", outputIterative)

	// nums, target, _ = getRandomNumsSlice(20)
	// outputIterative = SearchIterative(nums, target)
	// fmt.Println("\nSearchIterative:", outputIterative)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 3
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive := SearchRecursive(nums, target, 0, len(nums))
	fmt.Println("\nSearchRecursive:", outputRecursive)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 1
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive = SearchRecursive(nums, target, 0, len(nums))
	fmt.Printf("\nSearchRecursive: %2v \n\n", outputRecursive)
	// stdout.OutputToFile("file.log")

	stdout.OutputToFile("")

}
#+end_src
*** Go Recursive
#+begin_example go

// Binary Search Algorithm: The basic steps to perform Binary Search are:
//
// https://www.geeksforgeeks.org/binary-search/
//
//	Begin with the mid element of the whole array as a search key.
//	If the value of the search key is equal to the item then return an index of the search key.
//	Or if the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.
//	Otherwise, narrow it to the upper half.
//	Repeatedly check from the second point until the value is found or the interval is empty.
//
// # Binary Search Algorithm can be implemented in the following two ways
//
// Iterative Method
// Recursive Method

// SearchRecursive
//
// Credits: https://www.geeksforgeeks.org/binary-search/
//
// l, r := 0, len(nums)-1 // left & right
func SearchRecursive(nums []int, target int, l, r int) int {
	if r >= l {
		mid := (r + l) / 2 // Or l + (r - l) / 2.

		if nums[mid] == target {
			return mid // If the target is in the middle itself.
		} else if nums[mid] > target {
			rSub := mid - 1 // move to the left
			return SearchRecursive(nums, target, l, rSub)
		} else {
			lAdd := mid + 1 // move to the right
			return SearchRecursive(nums, target, lAdd, r)
		}
	}

	return -1
}

// Runtime: 79 ms, faster than 11.19% of Go online submissions for Binary Search.
// Memory Usage: 7.6 MB, less than 10.50% of Go online submissions for Binary Search.
func searchRecursive(nums []int, target int) int {
	return binarySearchRecursive(nums, target, 0, len(nums)-1)
}

// Runtime: 79 ms, faster than 11.19% of Go online submissions for Binary Search.
// Memory Usage: 7.6 MB, less than 10.50% of Go online submissions for Binary Search.
func binarySearchRecursive(nums []int, target, left, right int) int {
	var output int
	if left > right {
		return -1
	}
	mid := (left + right) / 2
	if nums[mid] == target {
		return mid
	} else if target < nums[mid] {
		output = binarySearchRecursive(nums, target, left, mid-1)
	} else {
		output = binarySearchRecursive(nums, target, mid+1, right)
	}
	return output
}

#+end_example

*** Go Alternative
#+NAME: binary-search
#+begin_example go

// Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.
// If target exists, then return its index. Otherwise, return -1.
//
// You must write an algorithm with O(log n) runtime complexity.
//
// https://leetcode.com/problems/binary-search/
//
/*
   EXAMPLES:
     Example 1:
        Input: nums = [-1,0,3,5,9,12], target = 9
        Output: 4
        Explanation: 9 exists in nums and its index is 4

     Example 2:
        Input: nums = [-1,0,3,5,9,12], target = 2
        Output: -1
        Explanation: 2 does not exist in nums so return -1

     Example 3:
        Input: arr[] = {10, 20, 30, 50, 60, 80, 110, 130, 140, 170}, x = 110
        Output: 6
        Explanation: Element x is present at index 6.

     Example 4:
        Input: arr[] = {10, 20, 30, 40, 60, 110, 120, 130, 170}, x = 175
        Output: -1
        Explanation: Element x is not present in arr[].
*/
//
// Constraints:
//
//   - 1 <= nums.length <= 104
//   - -104 < nums[i], target < 104
//   - All the integers in nums are unique.
//   - nums is sorted in ascending order.
package main

import (
	"fmt"
	"log"
	"sort"
	"stdout"
)

// Runtime: 68 ms, faster than 27.39% of Go online submissions for Binary SearchForLoop.
// Memory Usage: 6.7 MB, less than 94.45% of Go online submissions for Binary SearchForLoop.
func SearchForLoop(nums []int, target int) int {
	for i := 0; i < len(nums); i++ {
		if nums[i] == target {
			return i
		}
	}

	return -1
}

func getRandomNumsSlice(count int) ([]int, int, int) {
	nums := []int{10, 20, 30, 50, 60, 80, 110, 130, 140, 170}
	len := len(nums)
	for idx := 0; idx < count; idx++ {
		// nums = append(nums, rand.Int())
		nums = append(nums, nums[len-1]+idx*10)
	}
	sort.Slice(nums, func(i, j int) bool {
		return nums[i] < nums[j]
	})

	// len2 := len(nums)
	// mid := len2 - len1
	// fmt.Printf("nums: %v\n", nums)

	return nums, 60, 5

}

func getNumsTargets() ([]int, int, int) {
	nums := []int{10, 20, 30, 50, 60, 80, 110, 130, 140, 170}
	target := 110
	want := 6

	return nums, target, want
}

// Binary Search Algorithm: The basic steps to perform Binary Search are:
//
// https://www.geeksforgeeks.org/binary-search/
//
//	Begin with the mid element of the whole array as a search key.
//	If the value of the search key is equal to the item then return an index of the search key.
//	Or if the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.
//	Otherwise, narrow it to the upper half.
//	Repeatedly check from the second point until the value is found or the interval is empty.
//
// # Binary Search Algorithm can be implemented in the following two ways
//
// Iterative Method
// Recursive Method
func SearchIterative(nums []int, target int) int {
	n := len(nums) // length of the slice/array
	left := 0      // left: is the first position at 0
	right := n - 1 // right: 0 index means we subtract one from len

	for right-left > 1 {
		mid := (right + left) / 2
		// time.Sleep(time.Second * 1)
		// fmt.Printf("nums: %2v \n ", nums)
		// fmt.Printf("\rleft: %2v: %v | mid: %2v: %v | right: %2v: %v \n", left, nums[left], mid, nums[mid], right, nums[right])

		if target == nums[mid] {
			return mid // If target is in the middle itself
		} else if target > nums[mid] {
			// increment the position to right
			left = mid + 1 // If target is less than mid then it will be in the right subarray/slice
		} else {
			right = mid - 1 // else the target can only be present in the left subarray/slice
		}
	} // for as a while loop

	// If the element is not present in slice/array
	return -1
}

// SearchRecursive
//
// Credits: https://www.geeksforgeeks.org/binary-search/
//
// l, r := 0, len(nums)-1 // left & right
func SearchRecursive(nums []int, target int, l, r int) int {
	if r >= l {
		mid := (r + l) / 2 // Or l + (r - l) / 2.

		if nums[mid] == target {
			return mid // If the target is in the middle itself.
		} else if nums[mid] > target {
			rSub := mid - 1 // move to the left
			return SearchRecursive(nums, target, l, rSub)
		} else {
			lAdd := mid + 1 // move to the right
			return SearchRecursive(nums, target, lAdd, r)
		}
	}

	return -1
}

// Runtime: 31 ms, faster than 95.31% of Go online submissions for Binary Search.
// Memory Usage: 6.7 MB, less than 94.48% of Go online submissions for Binary Search.
//
// Runtime: 32 ms, faster than 93.68% of Go online submissions for Binary Search.
// Memory Usage: 6.5 MB, less than 99.96% of Go online submissions for Binary Search.
func searchMid(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := (low + high) / 2
		if nums[mid] == target {
			return mid
		} else if nums[mid] > target {
			high--
		} else {
			low++
		}
	}
	return -1
}

// Runtime: 40 ms, faster than 72.72% of Go online submissions for Binary Search.
// Memory Usage: 7.1 MB, less than 53.18% of Go online submissions for Binary Search.
//
// Runtime: 33 ms, faster than 91.94% of Go online submissions for Binary Search.
// Memory Usage: 7 MB, less than 61.39% of Go online submissions for Binary Search.
func search(nums []int, target int) int {
	for i := 0; i < len(nums); i++ {
		if nums[i] == target {
			return i
		}
	}
	return -1
}

// Runtime: 79 ms, faster than 11.19% of Go online submissions for Binary Search.
// Memory Usage: 7.6 MB, less than 10.50% of Go online submissions for Binary Search.
func searchRecursive(nums []int, target int) int {
	return binarySearchRecursive(nums, target, 0, len(nums)-1)
}

// Runtime: 79 ms, faster than 11.19% of Go online submissions for Binary Search.
// Memory Usage: 7.6 MB, less than 10.50% of Go online submissions for Binary Search.
func binarySearchRecursive(nums []int, target, left, right int) int {
	var output int
	if left > right {
		return -1
	}
	mid := (left + right) / 2
	if nums[mid] == target {
		return mid
	} else if target < nums[mid] {
		output = binarySearchRecursive(nums, target, left, mid-1)
	} else {
		output = binarySearchRecursive(nums, target, mid+1, right)
	}
	return output
}

func searchRunMain() {
	var nums []int
	var target int
	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 9
	fmt.Printf("search: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
	nums = []int{5}
	target = 5
	fmt.Printf("search: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
	nums = []int{5}
	target = -5
	fmt.Printf("search: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
	nums = []int{2, 5}
	target = 5
	fmt.Printf("search: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
	nums = []int{-1, 0, 5}
	target = 5
	fmt.Printf("searchRecursive: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 13
	fmt.Printf("searchRecursive: %v, %v, %v\n", searchRecursive(nums, target), nums, target)
}

func main() {
	log.SetFlags(log.Ldate | log.Lshortfile)
	log.Println("| 0704_binary-search/main.go: main()")
	nums := []int{-1, 0, 3, 5, 9, 12}
	target := 9

	searchRunMain()

	output := SearchForLoop(nums, target)
	fmt.Printf("\nSearchForLoop:%2v\n", output)

	nums, target, _ = getNumsTargets()
	outputIterative := SearchIterative(nums, target)
	fmt.Println("\nSearchIterative:", outputIterative)

	// nums, target, _ = getRandomNumsSlice(20)
	// outputIterative = SearchIterative(nums, target)
	// fmt.Println("\nSearchIterative:", outputIterative)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 3
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive := SearchRecursive(nums, target, 0, len(nums))
	fmt.Println("\nSearchRecursive:", outputRecursive)

	nums = []int{-1, 0, 3, 5, 9, 12}
	target = 1
	// nums, target, _ = getRandomNumsSlice(20)
	outputRecursive = SearchRecursive(nums, target, 0, len(nums))
	fmt.Printf("\nSearchRecursive: %2v \n\n", outputRecursive)
	// stdout.OutputToFile("file.log")

	stdout.OutputToFile("")

}
#+end_example

#+RESULTS: binary-search

*** TypeScript
#+begin_example typescript
function search(nums: number[], target: number): number {
  let low = 0;
  let high = nums.length - 1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] > target) {
      // high--;
      high = mid - 1;
    } else if (nums[mid] < target) {
      // low++
      low = mid + 1;
    }
  }
  return -1;
}
#+end_example

** Explanation
URL: https://leetcode.com/problems/binary-search/
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

*** Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

*** Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
*** More Examples
#+begin_example markdown
EXAMPLES:
  Example 1:
     Input: nums = [-1,0,3,5,9,12], target = 9
     Output: 4
     Explanation: 9 exists in nums and its index is 4

  Example 2:
     Input: nums = [-1,0,3,5,9,12], target = 2
     Output: -1
     Explanation: 2 does not exist in nums so return -1

  Example 3:
     Input: arr[] = {10, 20, 30, 50, 60, 80, 110, 130, 140, 170}, x = 110
     Output: 6
     Explanation: Element x is present at index 6.

  Example 4:
     Input: arr[] = {10, 20, 30, 40, 60, 110, 120, 130, 170}, x = 175
     Output: -1
     Explanation: Element x is not present in arr[].
#+end_example

** Constraints:
    - 1 <= nums.length <= 104
    - -104 < nums[i], target < 104
    - All the integers in nums are unique.
    - nums is sorted in ascending order.
* 1752. Check if Array Is Sorted and Rotated
** Source
*** GO
**** main.go
#+NAME: check-if-array-is-sorted-and-rotated
#+begin_src go :tangle ./1752-check-if-array-is-sorted-and-rotated/main.go :main no :noweb yes :comments link

// 1752. Check if Array Is Sorted and Rotated
// Easy
// Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.
// There may be duplicates in the original array.
//
// Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.
//
// Constraints:
//
//	1 <= nums.length <= 100
//	1 <= nums[i] <= 100
package main

import (
	"log"
	"time"

	"github.com/fatih/color"

	testcase "github.com/lloydlobo/leetcode/easy/1752-check-if-array-is-sorted-and-rotated/testcase"
)

// Runtime: 0 ms, faster than 100.00% of Go online submissions for Check if Array Is Sorted and Rotated.
// Memory Usage: 2 MB, less than 87.88% of Go online submissions for Check if Array Is Sorted and Rotated.
func CheckMiss(nums []int) bool {
	n := len(nums)
	if n < 3 {
		return true // Edge case when numbers set are small.
	}
	miss := false

	for i := 1; i < n; i++ {
		prevMoreThanCurr := nums[i-1] > nums[i]
		if !miss && prevMoreThanCurr {
			miss = true
		} else if prevMoreThanCurr {
			return false
		}
	}
	if miss {
		isLastLessThanEqualFirst := nums[n-1] <= nums[0]
		return isLastLessThanEqualFirst
	}
	return true
}

// if array is sorted and rotated then, there is only 1 break point where (nums[x] > nums[x+1]),
// if array is only sorted then, there is 0 break point.
//
// Compare all neignbour elements (a,b) in nums,
// the case of a > b can happen at most once.
// Note that the first element and the last element are also connected.
// If all a <= b, nums is already sorted.
// If all a <= b but only one a > b,
// rotate and make b the first element.
// Otherwise return false.
// # Complexity
// Time O(n)
// Space O(1)
// Runtime: 0 ms.
// Memory Usage: 2.1 MB.
func Check(nums []int) bool {
	count, n := 0, len(nums)
	if n < 3 {
		return true // Edge case when numbers set are small.
	}
	for i := 0; i < n; i++ {
		if nums[i] > nums[(i+1)%n] {
			count++
		}
		if count > 1 {
			return false
		}
	}
	return true // return (count <= 1)
}

func sleep(x time.Duration) {
	time.Sleep(time.Millisecond * x)
}

/*
# Examples:

    Example 1:

    Input: nums = [3,4,5,1,2]
    Output: true
    Explanation: [1,2,3,4,5] is the original sorted array.
    You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].

    Example 2:

    Input: nums = [2,1,3,4]
    Output: false
    Explanation: There is no sorted array once rotated that can make nums.

    Example 3:

    Input: nums = [1,2,3]
    Output: true
    Explanation: [1,2,3] is the original sorted array.
    You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
*/

func main() {
	var arrGot []bool
	var arrWant []bool

	t := &testcase.Testcase{}
	t.ArrNums, t.ArrWants = testcase.GetTestcase()

	color.Set(color.FgYellow, color.Bold)
	arrGot, arrWant = testcase.ExecForLoop(Check, t)
	go sleep(500)
	log.Printf(" ➜  got: %v | want: %v\n", arrGot, arrWant)
	arrGot, arrWant = testcase.ExecForLoop(CheckMiss, t)
	go sleep(500)
	log.Printf(" ➜  got: %v | want: %v\n", arrGot, arrWant)
	color.Unset()

	// fmt.Printf("➜ %2v | output: %11v | want: %11v\n\n", i, got, want)
}
#+end_src

#+RESULTS: check-if-array-is-sorted-and-rotated


**** main_test.go
*** TYPESCRIPT
#+begin_src typescript
function check(nums: number[]): boolean {
    const n: number = nums.length;
    if (n < 3) {
        return true;
    }
    let count = 0;
    for (let i = 0; i < n; i++) {
        if (nums[i] > nums[(i+1) % n]) {
            count++;
        }
        if (count > 1) {
            return false;
        }
    }
    return true;
};

function main(){
    const nums: number[] = [3,4,5,1,2];
    const want: boolean =  true;
    const got: boolean = check(nums);
    console.log(want, got);
}

main()
#+end_src

*** C
#+NAME: 1752-check-if-array-is-sorted-and-rotated
#+begin_src c :tangle ./1752-check-if-array-is-sorted-and-rotated/C/check.c :main no :noweb yes :comments link
 */
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>

#define BOOL bool
// #define SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

// 1752. Check if Array Is Sorted and Rotated
//
// Given an array nums, return true if the array was originally sorted in
// non-decreasing order, then rotated some number of positions (including zero).
// Otherwise, return false. There may be duplicates in the original array. Note:
// An array A rotated by x positions results in an array B of the same length
// such that A[i] == B[(i+x) % A.length], where % is the modulo operation
//
// Constraints:
// 1 <= nums.length <= 100
// 1 <= nums[i] <= 100
//
// Runtime: 2 ms.
// Memory Usage: 5.8 MB.
bool check(int *nums, int numsSize) {
  int count = 0;
  for (int i = 0; i < numsSize; i++) {
    printf("\n%d:%2d |%2d", i, nums[i], count);
    if (nums[i] > nums[(i + 1) % numsSize]) {
      count++;
    }
    if (count > 1) {
      return false;
    }
  }
  return true;
};

void printout(int *nums, bool want) {
  for (int i = 0; i < 5; i++) {
    printf("%d ", nums[i]);
  }
  printf("| want: %s\n", want ? "true" : "false");
}

int main() {
  int nums[5] = {3, 4, 5, 1, 2};
  bool want = true;
  printout(nums, want);
  int n = sizeof(nums) / sizeof(nums[0]); // is size_t but coerced as int.
  bool out = check(nums, n);
  printf("\ngot:%2s|want:%2s\n", out ? "true" : "false",
         want ? "true" : "false");
}
#+end_src
** Explanation
** Examples
* 1913. Maximum Product Difference Between Two Pairs
** sort
#+begin_src go :tangle ./1913-maximum-product-difference-between-two-pairs/go/algo/sort/sort.go :main no :comments link :noweb yes
package sort

import (
"sort"
)

// MaxProductDifferenceSort() sorts the slice nums.
// and returns product of first & last two integers.
//
// Using an unstable sort standard function.
//
// https://leetcode.com/submissions/detail/809639232/
//
// Runtime: 34 ms; Memory: 6.4 MB
func MaxProductDifferenceSort(nums []int) int {
n := len(nums)
sort.Ints(nums)
return (nums[n-1] * nums[n-2]) - (nums[0] * nums[1])
}
#+end_src

** clone
#+begin_src go :tangle ./1913-maximum-product-difference-between-two-pairs/go/algo/clone/clone.go :main no :comments link :noweb yes
package clone

import "sort"

type SortedKeys struct {
	Value int
	Id    int
}

// MaxProductDifferenceClone keeps the nums intact,
// and returns difference of the product of
// the 2 largest and 2 smallest numbers.
//
// Runtime: 69 ms; Memory: 8.5 MB
func MaxProductDifferenceClone(nums []int) int {
	n := len(nums)

	sortedNums := getSortIdx(nums, n)                 // Sort by value while keeping the index beside it.
	lg, sm, _ := getGreatestMultiplier(sortedNums, n) // Multiply and store id of first 2 and last two nums.

	return lg - sm // Return difference of largest to smallest product.
}

func getSortIdx(nums []int, size int) [][]int {
	var hash = make(map[int][]int)
	var keys = make([][]int, size)
	// Populate hash map with hashed nums and id.
	for i := 0; i < size; i++ {
		// get index of all nums before sorting
		hash[i] = []int{nums[i], i}
	}
	// Populate keys slice with hashed nums and id.
	for i := 0; i < len(hash); i++ {
		keys[i] = []int{hash[i][0], hash[i][1]}
	}
	// Sort by value while keeping the index beside it.
	sort.Slice(keys, func(i, j int) bool {
		return keys[i][0] > keys[j][0]
	})
	return keys
}

func getGreatestMultiplier(n [][]int, size int) (int, int, []int) {
	a, b, y, z := n[0][0], n[1][0], n[size-2][0], n[size-1][0]         // 9 8 4 2
	ida, idb, idy, idz := n[0][1], n[1][1], n[size-2][1], n[size-1][1] // a b y z

	large, small := a*b, y*z             // Populate 0*1, n-1*n. (products)
	abyzIdx := []int{ida, idb, idy, idz} // Populate 0,1,n-1,n. (ids)

	return large, small, abyzIdx
}

#+end_src

** minmax
#+begin_src go :tangle ./1913-maximum-product-difference-between-two-pairs/go/algo/minmax/minmax.go :main no :comments link :noweb yes
package minmax

// Is it like counting? and tallying?
func MaxProductDifferenceMinMax(nums []int) int {
	max1, max2 := nums[0], nums[1]
	if max1 < max2 {
		max1, max2 = max2, max1
	}
	min1, min2 := nums[0], nums[1]
	if min1 > min2 {
		min1, min2 = min2, min1
	}

	size := len(nums)

	for i := 2; i < size; i++ {
		num := nums[i]

		if num > max1 {
			max2 = max1
			max1 = num
		} else if num > max2 {
			max2 = num
		}

		if num < min1 {
			min2 = min1
			min1 = num
		} else if num < min2 {
			min2 = num
		}
	}

	return max1*max2 - min1*min2
}
#+end_src

